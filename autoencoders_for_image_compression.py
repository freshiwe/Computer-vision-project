# -*- coding: utf-8 -*-
"""Autoencoders for image compression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iRL4soGKIZQ8s5wBHQlLrCBY7V0wi7oa

# Computer Vision Masterclass - Autoencoders for image compression

## Linear autoencoder

### Importing the libraries
"""

import tensorflow as tf
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Dense, Input
import numpy as np
import matplotlib.pyplot as plt
tf.__version__

"""### Loading the dataset

- Dataset: https://keras.io/api/datasets/mnist/
"""

from tensorflow.keras.datasets import mnist

(X_train, y_train), (X_test, y_test) = mnist.load_data()

X_train.shape, y_train.shape

X_test.shape, y_test.shape

X_train[0]

y_train[0]

"""### Visualizing the images"""

np.random.randint(0, 59999)

i = np.random.randint(0, 59999)
print(y_train[i])
plt.imshow(X_train[i], cmap='gray');

np.arange(0, 100)

width = 10
height = 10
fig, axes = plt.subplots(height, width, figsize=(15, 15))
#print(axes.shape)
axes = axes.ravel() # -> (10,10) -> [100]
#print(axes.shape)
for i in np.arange(0, width * height):
  index = np.random.randint(0, 59999)
  axes[i].imshow(X_train[index], cmap = 'gray')
  axes[i].set_title(y_train[index], fontsize = 8)
  axes[i].axis('off')
plt.subplots_adjust(hspace=0.4)

"""### Pre-processing the images"""

X_train[0].min(), X_train[0].max()

X_train = X_train / 255
X_test = X_test / 255

X_train[0].min(), X_train[0].max()

X_train.shape, X_test.shape

X_train.shape[0], X_train.shape[1], X_train.shape[2]

X_train = X_train.reshape(X_train.shape[0], X_train.shape[1] * X_train.shape[2])
X_train.shape

X_test = X_test.reshape(X_test.shape[0], X_test.shape[1] * X_test.shape[2])
X_test.shape

"""### Building and training the linear autoencoder"""

# 784 - 128 - 64 - 32 - 64 - 128 - 784

autoencoder = Sequential()

# Encode
autoencoder.add(Dense(units = 128, activation='relu', input_dim = 784))
autoencoder.add(Dense(units = 64, activation='relu'))
autoencoder.add(Dense(units = 32, activation='relu')) # Encoded image

# Decode
autoencoder.add(Dense(units = 64, activation='relu'))
autoencoder.add(Dense(units = 128, activation='relu'))
autoencoder.add(Dense(units = 784, activation='sigmoid'))

autoencoder.summary()

autoencoder.compile(optimizer='Adam', loss='binary_crossentropy', metrics = ['accuracy'])

y_train

autoencoder.fit(X_train, X_train, epochs=50)

"""### Encoding the images"""

autoencoder.summary()

autoencoder.input

autoencoder.get_layer('dense_2').output

encoder = Model(inputs = autoencoder.input, outputs = autoencoder.get_layer('dense_2').output)

encoder.summary()

plt.imshow(X_test[0].reshape(28,28), cmap='gray');

X_test[0].shape

X_test[0].reshape(1, -1).shape

encoded_image = encoder.predict(X_test[0].reshape(1,-1))

encoded_image, encoded_image.shape

8 * 4

plt.imshow(encoded_image.reshape(8,4), cmap='gray');

"""### Decoding the images"""

autoencoder.summary()

input_layer_decoder = Input(shape=(32,))
decoder_layer1 = autoencoder.layers[3]
decoder_layer2 = autoencoder.layers[4]
decoder_layer3 = autoencoder.layers[5]
decoder = Model(inputs = input_layer_decoder, outputs = decoder_layer3(decoder_layer2(decoder_layer1(input_layer_decoder))))
decoder.summary()

decoded_image = decoder.predict(encoded_image)

decoded_image.shape

plt.imshow(X_test[0].reshape(28,28), cmap = 'gray');

plt.imshow(decoded_image.reshape(28,28), cmap='gray');

"""### Encoding and decoding the test images"""

X_test.shape[0] # 9999

n_images = 10
test_images = np.random.randint(0, X_test.shape[0] - 1, size = n_images)
#print(test_images)
plt.figure(figsize=(18,18))
for i, image_index in enumerate(test_images):
  #print(i, image_index)
  # Original image
  ax = plt.subplot(10,10,i + 1)
  plt.imshow(X_test[image_index].reshape(28,28), cmap='gray')
  plt.xticks(())
  plt.yticks(())

  # Coded images
  ax = plt.subplot(10,10,i + 1 + n_images)
  encoded_image = encoder.predict(X_test[image_index].reshape(1,-1))
  plt.imshow(encoded_image.reshape(8,4), cmap = 'gray')
  plt.xticks(())
  plt.yticks(())

  # Decoded images
  ax = plt.subplot(10,10,i + 1 + n_images * 2)
  plt.imshow(decoder.predict(encoded_image).reshape(28,28), cmap='gray')
  plt.xticks(())
  plt.yticks(())

"""## Convolutional autoencoders

### Importing the libraries
"""

from tensorflow.keras.layers import Conv2D, MaxPooling2D, UpSampling2D, Reshape, Flatten

"""### Loading the dataset

- Dataset: https://keras.io/api/datasets/fashion_mnist/
"""

from tensorflow.keras.datasets import fashion_mnist

(X_train, y_train), (X_test, y_test) = fashion_mnist.load_data()

X_train.shape, y_train.shape

X_test.shape, y_test.shape

"""### Visualizing the images"""

classes = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat', 'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']
width = 10
height = 10

fig, axes = plt.subplots(height, width, figsize = (15,15))
axes = axes.ravel()
for i in np.arange(0, width * height):
    index = np.random.randint(0, 60000)
    axes[i].imshow(X_train[index], cmap = 'gray' )
    axes[i].set_title(classes[y_train[index]], fontsize = 8)
    axes[i].axis('off')

plt.subplots_adjust(hspace=0.4)

"""### Pre-processing the images"""

X_train = X_train / 255
X_test = X_test / 255

X_train.shape, X_test.shape

X_train = X_train.reshape((len(X_train), 28, 28, 1))
X_test = X_test.reshape((len(X_test), 28, 28, 1))

X_train.shape, X_test.shape

"""### Building and training the convolutional autoencoder"""

# Padding: https://www.pico.net/kb/what-is-the-difference-between-same-and-valid-padding-in-tf-nn-max-pool-of-tensorflow

autoencoder = Sequential()

# Encoder
autoencoder.add(Conv2D(filters = 16, kernel_size=(3,3), activation='relu', padding='valid', input_shape=(28,28,1)))
autoencoder.add(MaxPooling2D(pool_size=(2,2)))

autoencoder.add(Conv2D(filters = 8, kernel_size=(3,3), activation='relu', padding='same'))
autoencoder.add(MaxPooling2D(pool_size=(2,2), padding='same'))

#autoencoder.summary()

autoencoder.add(Conv2D(filters=8, kernel_size=(3,3), activation='relu', padding = 'same', strides=(2,2)))

autoencoder.add(Flatten())

#autoencoder.summary()

# Decoder

autoencoder.add(Reshape((4,4,8)))
#autoencoder.summary()
autoencoder.add(Conv2D(filters = 8, kernel_size=(3,3), activation='relu', padding='same'))
#autoencoder.summary()
autoencoder.add(UpSampling2D(size=(2,2)))
#autoencoder.summary()

autoencoder.add(Conv2D(filters = 8, kernel_size=(3,3), activation='relu', padding='same'))
autoencoder.add(UpSampling2D(size=(2,2)))

autoencoder.add(Conv2D(filters = 16, kernel_size=(3,3), activation='relu'))
autoencoder.add(UpSampling2D(size=(2,2)))

autoencoder.add(Conv2D(filters = 1, kernel_size=(3,3), activation='sigmoid', padding='same'))
autoencoder.summary()

# Output = (Input - Filter + 1) / Stride

# Input: (28, 28, 1)
# Filter size: 3
# Output: (28 - 3 + 1) / 1 = 26 -> (26, 26, 16)

# UpSampling2D: (16, 16, 8)
# Filter size: 3
# Output: (16 - 3 + 1) / 1 = 14 -> (14, 14, 16)

(28 - 3 + 1) / 1, (16 - 3 + 1) / 1

autoencoder.compile(optimizer='Adam', loss='binary_crossentropy', metrics = ['accuracy'])

autoencoder.fit(X_train, X_train, epochs = 50)

"""### Encoding and decoding the test images"""

autoencoder.summary()

encoder = Model(inputs = autoencoder.input, outputs = autoencoder.get_layer('flatten_10').output)
encoder.summary()

coded_test_images = encoder.predict(X_test)

coded_test_images.shape

coded_test_images[0]

decoded_test_images = autoencoder.predict(X_test)
decoded_test_images.shape

n_images = 10
test_images = np.random.randint(0, X_test.shape[0], size = n_images)
plt.figure(figsize=(18,18))
for i, image_index in enumerate(test_images):
  # Original images
  ax = plt.subplot(10,10, i + 1)
  plt.imshow(X_test[image_index].reshape(28,28), cmap='gray')
  plt.xticks(())
  plt.yticks(())

  # Coded images
  ax = plt.subplot(10,10, i + 1 + n_images)
  plt.imshow(coded_test_images[image_index].reshape(16,8), cmap='gray')
  plt.xticks(())
  plt.yticks(())

  # Decoded images
  ax = plt.subplot(10,10, i + 1 + n_images * 2)
  plt.imshow(decoded_test_images[image_index].reshape(28,28), cmap='gray')
  plt.xticks(())
  plt.yticks(())

16 * 8